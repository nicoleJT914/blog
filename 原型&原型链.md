一切引用类型都是对象，对象就是属性的集合

判断值类型通过`typeof`，判断引用类型用`instanceof`

对象是通过函数创建的，但是函数也是一种对象
```js
function Person(name, age) {
  this.name = name
  this.age = age
}
var person = new Person('jack', 35)
```

![原型图1](http://images.cnitblog.com/blog/138012/201409/172130097842386.png)

函数也是对象，因此也可以给函数添加自定义属性

js给函数一个默认属性`prototype`,`prototype`的属性值是一个对象，属性值的其中一个默认属性就是`constructor`，指向这个函数本身

举例：Object的`prototype`的属性里不止`constructor`一个属性，还有其他默认添加的自定义属性
```js
var o = new Object()
```
对象o是由函数Object创建的，o可以调用·Object.prototype·中的属性。

另外，每个对象都有一个隐藏属性`__proto__`(隐式原型),该属性引用了创建这个对象的函数的`prototype`

即：`o.__proto__ === Object.prototype`

![原型图2](http://images.cnitblog.com/blog/138012/201409/181509180812624.png)
```js
var o = {}
console.log(o.__proto__ === Object.prototype) //true
```
`Object.prototype`也是一个对象，它的`__proto__`指向哪里呢？理论上说对象的`__proto__`应给指向`Object.prototype`。

**但是这个是特例，`Object.prototype.__proto__ === null`**

![原型图3](http://images.cnitblog.com/blog/138012/201409/181510403153733.png)
![原型图4](http://images.cnitblog.com/blog/138012/201409/181512489403338.png)
![原型图5](http://images.cnitblog.com/blog/138012/201409/181512068463597.png)

上面说到对象的`__proto__`应给指向`Object.prototype`

因此，`Foo.prototype.__proto__ === Object.prototype`，`Function.prototype.__proto__ === Object.prototype`

而所有函数是由Function创建的对象，因此`Foo.__proto__ === Function.protptype`，`Object.__proto__ === Function.prototype`,`Function.__proto__ === Function.prototype`

下面借由`instanceof`来进一步说明一下，`instanceof`表示的就是一种继承关系，或者说原型链的结构

`instanceof`的定义：whether an object in its prototype chain has the prototype property of a constructor.

`A instanceof B`具体的判断规则：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false

因此以下规则就很好理解了
```js
console.log(Object instanceof Function)  //true
console.log(Function instanceof Object)  //true
console.log(Function instanceof Function)  //true
console.log(Object instanceof Object) //true
```

当明白原型的概念后，就可以来理解继承了。JS中的继承就是通过原型链来体现的
```js
function Foo() {}
Foo.prototype = {
  a: 100,
  b: 200
}
var f1 = new Foo()
f1.a = 10
console.log(f1.a)
console.log(f1.b)
```
来解释一下为什么f1都读到b属性：访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着`__proto__`这条链向上找，这就是**原型链**。

如何区分属性是自有的还是从原型中找到的？使用`hasOwnProperty`。
