# 模块化编程
1. 原始写法
```
function m1() {

}
function m2() {1

}
```
污染全局变量

无法避免命名冲突

2. 对象写法
```
var module1 = new Object({
  _count: 0,
  m1： function() {

  }
  m2: function() {

  }
})
```
调用：module1.m1()

暴露模块成员

3. IIFE(模块的基本写法)
```
var module1= fuction() {
  var _count = 0
  var m1 = function() {

  }
  var m2 = function() {

  }
  return {
    m1: m1,
    m2: m2
  }
}()
```
无法读取内部变量_count

4. 放大模式
```
var module1 = (function(mod) {
  mod.m3 = function() {

  }
  return mod
})(module1)
```
为module1添加m3方法，并返回module1

5. 宽放大模式
```
var module1 = (function(mod) {
  //...
  return mod
})(window.module1 || {})
```
参数可以使空对象

6. 输入全局变量
模块的独立性
```
var module1 = (function($, YAHOO) {

})(jQuery, YUI)
```
将两个库当做参数传进module1中

# AMD规范
1. CommonJS (服务器端模块规范)
node.js 代表“JS模块化编程“的诞生， 参照的是CommonJS规范

CommonJS中的全局变量require()，用来加载模块

EX: 加载模块math.js
```
  var math = require('math')
  math.add(2,3)  //5
```
2. AMD的诞生
CommonJS对客户端模块不适用

加载模块需要从服务端读取模块，有耗时

加载完成之前都不能继续下面的操作，会造成浏览器“假死”状态

客户端模块无法采用“同步加载synchronous”，而需要采用“异步加载asynchronous”

这就是AMD诞生的背景
3. AMD
asynchronous module definition

AMD异步加载模块，依赖模块的语句放在回调函数中

AMD中require的用法：`require([module], callback)`

EX: 异步加载模块math.js
```
  require(['math'], function(math) {
    math.add(2, 3)
  })
```
目前，主要是`require.js`和`curl.js`两个库实现了AMD规范

# require.js
1. require.js的诞生背景
最原始的做法：所有要引入的模块放在同一个文件中

如main.js:
```
<script src="a.js"></script>
<script src="b.js"></script>
<script src="c.js"></script>
<script src="d.js"></script>
```
存在问题：

加载脚本时，会停止渲染网页。脚本数很多时，会使浏览器较长时间内失去响应

必须严格保证脚本的执行顺序，依赖性越大的脚本，放在越后面。难以维护

require.js解决的问题：

- 实现js文件的异步加载，避免网页失去响应

- 管理模块之间的依赖性，便于代码的编写和维护

2. require最佳实践
require.js加载的模块必须按照AMD规范来写

若要加载的模块不符合AMD规范，须在require.config()中进行配置

require.js每加载一个模块，就发出一个HTTP请求

r.js是require.js的一个优化工具，当模块部署完毕以后，可以用其将多个模块合并在一个文件中，减少HTTP请求数

# 为什么要使用模块化?
- 可维护性
良好设计的模块会尽量与外部的代码撇清关系，以便于独立对其进行改进和维护。
- 可复用性
- 解决命名冲突 
- 各模块依赖管理 
 
# 详解JavaScript模块化开发

[详解JavaScript模块化开发](https://segmentfault.com/a/1190000000733959)
- AMD
`define(id?, dependencies?, factory)`
AMD是异步的理念
因此依赖前置，依赖先执行！

- CMD
```
define(factory(require, exports, module){

})
```

- CommonJS
加载模块： `require()`
输出模块变量： `module.exports`对象
```
//模块定义 myModel.js

var name = 'Byron';

function printName(){
    console.log(name);
}

function printFullName(firstName){
    console.log(firstName + name);
}

module.exports = {
    printName: printName,
    printFullName: printFullName
}

//加载模块

var nameModule = require('./myModel.js');

nameModule.printName();
```

